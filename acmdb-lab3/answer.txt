- For the page eviction policy, I choose to randomly evict a page when there is insufficient space in the buffer pool.

- For B+ tree insertion, I fill in `BTreeFile.splitLeafPage` and `BTreeFile.splitInternalPage`. In `BTreeFile.splitLeafPage`, first I create a new empty page and move half of the tuples to the new page. Then I update the sibling pointers and finally I deal with the parent. In `BTreeFile.splitInternalPage`, first I create a new empty page and move half of the entries to the new page. Then I change the parent pointers of moved children from the page to the right page. Last I extract the middle key and construct a new entry to be pushed to the parent page.

- For B+ tree deletion, I complete the two operations: redistribute and merge. As for the redistribute operation, I fill in  `BTreeFile.stealFromLeafPage`, `BTreeFile.stealFromLeftInternalPage` and `BTreeFile.stealFromRightInternalPage`. In `BTreeFile.stealFromLeafPage`, first I move some of the tuples from the sibling to the page so that the tuples are evenly distributed and then update the corresponding parent entry. For `BTreeFile.stealFromLeftInternalPage`, first I steal entries from the left sibling, then I update the parent entry and at last I update parent pointers. `BTreeFile.stealFromRightInternalPage` is quite similar to `BTreeFile.stealFromLeftInternalPage`. As for the merge operation, I fill in `BTreeFile.mergeLeafPages` and `BTreeFile.mergeInternalPages`. In `BTreeFile.mergeLeafPages`, first I move all the tuples from the right page to the left page. Then I update the sibling pointers, make the right page available for reuse and delete the entry in the parent. In `BTreeFile.mergeInternalPages`, first I pull down the corresponding key from the parent entry and move all the entries from right page to the left page. Then I update the parent pointers, make the right page available for reuse and delete the entry in the parent.
  
- I think that the comment of `IndexPredicate.equals` is quite confusing. Hence, I implement `IndexPredicate.equals` according to my own idea (that is, `return op.equals(ipd.op) && fvalue.equals(ipd.fvalue)`). Besides, I add a new API `IndexPredicate.filter`, which is similar to `Predicate.filter`.

- The comments of many functions mention lock and synchronization but I ignore that when implementing these functions.

- I spent about two days understanding the code and filling in the missing pieces. Some functions have the comment `not necessary for lab1`, which I suppose that I should fill in when writing lab2 but `README.md` doesn't mention. For example, `BufferPool.discardPage`, `HeapFile.writePage`, `HeapPage.markSlotUsed` and so on. I fill in these functions for insurance.